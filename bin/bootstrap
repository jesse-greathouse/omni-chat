#!/usr/bin/env perl
use strict;
use warnings;
use Cwd qw(abs_path);
use Digest::SHA qw(sha256_hex);
use File::Basename qw(dirname);
use File::Path qw(make_path remove_tree);
use File::Find qw(find);
use File::Glob qw(bsd_glob);
use File::Spec;
use File::Temp qw(tempdir);
use POSIX qw(uname);

# --------------------------
# Config (override via env)
# --------------------------
my $SWITCH     = $ENV{OMNI_OCAML_SWITCH} // 'omni-irc-dev';
my $REPO_URL   = $ENV{OMNI_IRC_REPO}    // 'https://github.com/jesse-greathouse/omni-irc';
my $REV        = $ENV{OMNI_IRC_REV}     // '0.1.18';   # preferred tag/branch for prebuilt & sources
my $OCAML_HINT = $ENV{OMNI_OCAML_HINT}  // '5.3.0';    # preferred OCaml version

$ENV{OPAMYES}  = '1';
$ENV{OPAMROOT} = $ENV{OPAMROOT} // "$ENV{HOME}/.opam";

# Clear env that can confuse opam/ocaml
delete @ENV{qw(
  OPAMSWITCH OCAMLLIB OCAMLPATH CAML_LD_LIBRARY_PATH CAML_LD_LIBRARY_PATH__F
  OCAML_TOPLEVEL_PATH FLEXLINKFLAGS FLEXDLL_CHAIN MAKE MAKEFLAGS CC CL
)};

sub dief { printf STDERR shift, @_; exit 1 }

# --------------------------
# Resolve absolute tool paths
# --------------------------
sub _is_exec {
  my ($p) = @_;
  return unless defined $p && length $p;
  return (-f $p && -x $p) ? $p : undef;
}
sub _join {
  my ($dir, $cmd) = @_;
  my $p = File::Spec->catfile($dir, $cmd);
  return _is_exec($p);
}
sub resolve_tool {
  my ($name) = @_;
  # 1) explicit env overrides
  my @env_keys = (
    uc($name) . '_EXE',              # e.g. OPAM_EXE, GIT_EXE
    'OMNI_' . uc($name) . '_EXE',    # e.g. OMNI_OPAM_EXE, OMNI_GIT_EXE
  );
  for my $k (@env_keys) {
    my $v = $ENV{$k};
    if (my $p = _is_exec($v)) { return $p }
  }
  # 2) PATH search (best effort; PATH may be minimal)
  my $PATH = $ENV{PATH} // '';
  for my $d (split /:/, $PATH) {
    if (my $p = _join($d, $name)) { return $p }
  }
  # 3) common install prefixes (macOS/Homebrew, MacPorts, Linux user bin)
  my @common = grep { defined && length } (
    '/opt/homebrew/bin',     # Apple Silicon Homebrew
    '/usr/local/bin',        # Intel mac + many Linux
    '/opt/local/bin',        # MacPorts
    "$ENV{HOME}/.local/bin", # Linux user installs
    '/usr/bin',              # system
  );
  for my $d (@common) {
    if (my $p = _join($d, $name)) { return $p }
  }
  return undef;
}

my $OPAM = resolve_tool('opam')
  or dief("opam not found. Set OPAM_EXE to its full path (e.g., /opt/homebrew/bin/opam) and re-run.\n");
my $GIT  = resolve_tool('git')
  or dief("git not found. Set GIT_EXE to its full path and re-run.\n");

sub run {
  my (@cmd) = @_;
  system @cmd;
  my $code = $? >> 8;
  $code == 0 or dief("Command failed (%d): %s\n", $code, join(' ', map { /\s/ ? "'$_'" : $_ } @cmd));
}
sub capture {
  my (@cmd) = @_;
  open my $fh, "-|", @cmd or dief("Failed to spawn: %s\n", join(' ', @cmd));
  local $/;
  my $out = <$fh>;
  close $fh;
  my $code = $? >> 8;
  $code == 0 or dief("Command failed (%d): %s\n", $code, join(' ', @cmd));
  return $out;
}

sub which {
  my ($exe) = @_; for my $d (split /:/, ($ENV{PATH}||'')) { my $p = "$d/$exe"; return $p if -x $p }
  return undef;
}

sub curl_or_wget {
  return (which('curl') ? 'curl' : (which('wget') ? 'wget' : undef));
}

sub http_head_302_or_404 {
  my ($url) = @_;
  my $tool = curl_or_wget() or return undef;
  if ($tool eq 'curl') {
    my $out = `curl -Is -o /dev/null -w "%{http_code}" "$url" 2>/dev/null`; chomp $out; return $out;
  } else {
    system("wget -q --spider \"$url\""); my $code = $? >> 8;
    return $code == 0 ? "200" : "404";
  }
}

sub http_download {
  my ($url, $dest) = @_;
  my $tool = curl_or_wget() or dief("Need curl or wget to download assets\n");
  if ($tool eq 'curl') {
    system('curl', '-fL', '-o', $dest, $url) == 0 or dief("Download failed: %s\n", $url);
  } else {
    system('wget', '-O', $dest, $url) == 0 or dief("Download failed: %s\n", $url);
  }
}

sub unzip_to {
  my ($zip, $dest) = @_;
  mkdir $dest unless -d $dest;
  system('unzip', '-oq', $zip, '-d', $dest) == 0 or dief("unzip failed for %s\n", $zip);
}

sub os_arch {
  my ($sysname, $nodename, $release, $version, $machine) = uname();
  my $plat = $^O eq 'darwin' ? 'macos' : 'linux';
  my $arch = ($machine =~ /arm64|aarch64/i) ? 'arm64' : 'x64';
  return ($plat, $arch);
}

# --------------------------
# Gatekeeper/MOTW parity
# --------------------------
sub have_xattr { return which('xattr') ? 1 : 0 }

sub prompt_yes_no {
  my ($msg, $default_yes) = @_;
  my $def = $default_yes ? 'Y/n' : 'y/N';
  print "$msg [$def]: ";
  my $ans = <STDIN>;
  return $default_yes unless defined $ans;
  chomp $ans; $ans =~ s/^\s+|\s+$//g;
  return 1 if $ans =~ /^(y|yes)$/i;
  return 0 if $ans =~ /^(n|no)$/i;
  return $default_yes;
}

sub macos_clear_quarantine_recursively {
  my ($path) = @_;
  return unless $^O eq 'darwin';
  return unless have_xattr();

  my $auto = $ENV{OMNI_AUTO_UNQUARANTINE} // 1;
  my $doit = 0;
  if ($auto) {
    $doit = 1;
  } else {
    print "\n";
    print "───────────────────────────────────────────────────────────────\n";
    print "Unsigned package notice (macOS)\n";
    print "This installer downloaded an UNSIGNED package. macOS Gatekeeper\n";
    print "may block it the first time you run it.\n\n";
    print "Option A) I will approve it manually:\n";
    print "  - Finder → Right-click the app/binary → Open → Open\n";
    print "  - Or System Settings → Privacy & Security → 'Open Anyway'\n\n";
    print "Option B) Remove the quarantine flag now (requires consent):\n";
    print "  This runs: xattr -dr com.apple.quarantine '$path'\n";
    print "───────────────────────────────────────────────────────────────\n";
    $doit = prompt_yes_no("Remove quarantine attribute now?", 1);
  }

  if ($doit) {
    my @cmd = ('xattr', '-dr', 'com.apple.quarantine', $path);
    system(@cmd);
    my $code = $? >> 8;
    if ($code != 0) {
      print "Warning: failed to clear quarantine on '$path' (exit $code).\n";
      print "You can do this manually:\n";
      print "  xattr -dr com.apple.quarantine '$path'\n";
    } else {
      print "[bootstrap] Cleared macOS quarantine on: $path\n";
    }
  } else {
    print "OK. Leaving quarantine in place. You may need to approve the app\n";
    print "manually on first launch (see instructions above).\n";
  }
}

# --------------------------
# Tag/branch resolver (parity with PS)
# --------------------------
sub resolve_release_ref {
  my ($repo, $rev) = @_;
  my @candidates;
  if ($rev =~ /^\d/) { push @candidates, "v$rev" }  # prefer vX.Y.Z for numeric input
  push @candidates, $rev;

  # tags first
  for my $cand (@candidates) {
    my $out = `git ls-remote --tags --refs $repo refs/tags/$cand 2>/dev/null`;
    return { kind => 'tag', name => $cand } if $out && $? == 0;
  }
  # then heads
  for my $cand (@candidates) {
    my $out = `git ls-remote --heads $repo refs/heads/$cand 2>/dev/null`;
    return { kind => 'head', name => $cand } if $out && $? == 0;
  }
  dief("Could not find tag or branch for '%s' (tried: %s)\n", $rev, join(', ', @candidates));
}

sub clone_or_update_shallow {
  my ($repo, $ref, $dest) = @_;
  my $parent = dirname($dest);
  make_path($parent) unless -d $parent;

  if (!-d $dest) {
    run('git', 'clone', '--depth', '1', '--branch', $ref->{name}, $repo, $dest);
  } else {
    print "Reusing $dest\n";
    run('git', '-C', $dest, 'fetch', '--depth', '1', '--tags', 'origin', $ref->{name});
    if ($ref->{kind} eq 'tag') {
      run('git', '-C', $dest, 'checkout', '--force', "refs/tags/$ref->{name}");
    } else {
      run('git', '-C', $dest, 'checkout', '--force', $ref->{name});
    }
    run('git', '-C', $dest, 'reset', '--hard', '--quiet');
  }
}

# --------------------------
# Prebuilt installer
# --------------------------
sub install_prebuilt_if_available {
  my ($ver) = @_;
  my ($plat, $arch) = os_arch();
  my $owner = 'jesse-greathouse';
  my $repo  = 'omni-irc';
  my $base  = "https://github.com/$owner/$repo/releases";

  my @candidates = (
    ["latest", "$base/latest/download/omni-irc-client-$plat-$arch.zip"],
    ["v$ver",  "$base/download/v$ver/omni-irc-client-$ver-$plat-$arch.zip"],
  );

  my $root = "$ENV{HOME}/.local/omni-irc/pkg";
  my $chosen;
  for my $c (@candidates) {
    my ($label, $url) = @$c;
    my $code = http_head_302_or_404($url);
    next unless $code && ($code eq '200' || $code eq '302');
    $chosen = [$label, $url]; last;
  }
  return undef unless $chosen;

  my ($label, $url) = @$chosen;
  my $inst = "$root/$label";
  my $bindir = "$inst/bin";
  my $tmp = tempdir(CLEANUP => 1);
  my $zip = "$tmp/pkg.zip";

  print "[bootstrap] fetching prebuilt client: $url\n";
  http_download($url, $zip);

  unzip_to($zip, $inst);

  # macOS: explain/quarantine handling (parity with PS Unblock-File)
  if ($^O eq 'darwin') {
    print "\n";
    print "Note (macOS): this is an unsigned package. Gatekeeper may prompt on\n";
    print "first launch. You can approve manually, or allow the script to remove\n";
    print "the quarantine attribute on the extracted files.\n";
    macos_clear_quarantine_recursively($inst);
  }

  mkdir $bindir unless -d $bindir;

  # Expect the zip to contain ./omni-irc-client (or bin/). Normalize to $bindir/omni-irc-client
  my $found = '';
  for my $cand ("$inst/omni-irc-client", "$inst/bin/omni-irc-client") {
    if (-x $cand) { $found = $cand; last; }
  }
  if (!$found) {
    my $try = `find "$inst" -type f -name omni-irc-client 2>/dev/null`; chomp $try;
    $found = $try if $try && -x $try;
  }
  $found or dief("omni-irc-client not found in extracted package\n");

  system('chmod', '+x', $found);
  system('mkdir', '-p', $bindir);
  run('cp', '-f', $found, "$bindir/omni-irc-client");

  $ENV{OMNI_IRC_CLIENT} = "$bindir/omni-irc-client";
  print "[bootstrap] using prebuilt binary at $ENV{OMNI_IRC_CLIENT}\n";
  return 1;
}

print "[bootstrap] Using OPAMROOT=$ENV{OPAMROOT}\n";
print "[bootstrap] using opam at: $OPAM\n";
print "[bootstrap] using git  at: $GIT\n";

# 0.5) Try prebuilt ZIP first; fall back to opam flow if unavailable
if (install_prebuilt_if_available($REV)) {
  print "[bootstrap] prebuilt client installed. Skipping opam build.\n";
  $ENV{PATH} = dirname($ENV{OMNI_IRC_CLIENT}) . ":" . ($ENV{PATH}||'');
  system($ENV{OMNI_IRC_CLIENT}, '--help');
  print "\nDone. This terminal now has OMNI_IRC_CLIENT=$ENV{OMNI_IRC_CLIENT}\n";
  print "*******************************************************************\n";
  print "*  Omni-IRC bootstrap is COMPLETE (prebuilt). Close this window.  *\n";
  print "*******************************************************************\n";
  exit 0;
}

# --------------------------
# opam fallback (build from source)
# --------------------------

# ensure OPAM root and init if missing
if (!-d $ENV{OPAMROOT}) { make_path($ENV{OPAMROOT}); }
my $config = "$ENV{OPAMROOT}/config";
if (!-f $config) {
  run($OPAM, 'init', '--disable-sandboxing');  # fine on macOS/Linux too
}

# repo check/add; handle stale $OPAMROOT/repo/default
my $repo_dir = "$ENV{OPAMROOT}/repo/default";
my $repos = '';
eval { $repos = capture($OPAM, 'repo', 'list', '--short'); 1 } or $repos = '';
my %listed = map { $_ => 1 } grep { length } split(/\r?\n/, $repos);

if (!$listed{default}) {
  if (-d $repo_dir) {
    print "Repo dir exists but 'default' is not registered; removing stale dir and re-adding...\n";
    my $ok_rm = eval { remove_tree($repo_dir, { error => \my $err }); 1 };
    if (!$ok_rm) {
      warn "Could not remove stale repo dir at $repo_dir. Attempting 'opam repo set-url'...\n";
      eval { run($OPAM, 'repo', 'set-url', 'default', 'https://opam.ocaml.org', '--set-default'); 1 }
        or dief("opam repo registration is inconsistent and the stale dir could not be removed. Close shells/IDEs, delete '%s' manually, then re-run.\n", $repo_dir);
    }
  }
  my $repos2 = '';
  eval { $repos2 = capture($OPAM, 'repo', 'list', '--short'); 1 } or $repos2 = '';
  my %listed2 = map { $_ => 1 } grep { length } split(/\r?\n/, $repos2);
  if (!$listed2{default}) {
    run($OPAM, 'repo', 'add', 'default', 'https://opam.ocaml.org', '--set-default');
  }
} else {
  print "Default repo already registered.\n";
}

print "Updating opam package index...\n";
run($OPAM, 'update');

# create switch if missing (prefer ocaml-compiler.$OCAML_HINT, then 5.2.1, then base)
my $have = capture($OPAM, 'switch', 'list', '--short');
my %have = map { $_ => 1 } grep { length } split(/\r?\n/, $have);

if (!$have{$SWITCH}) {
  print "No '$SWITCH' switch found. Creating it...\n";
  my @candidates;
  push @candidates, "ocaml-compiler.$OCAML_HINT" if $OCAML_HINT;
  push @candidates, "ocaml-compiler.5.2.1";
  push @candidates, "ocaml-base-compiler";
  my $ok = 0;
  for my $spec (@candidates) {
    print "  - trying package set: $spec\n";
    my $rc = system($OPAM, 'switch', 'create', $SWITCH, '--packages', $spec);
    if (($rc >> 8) == 0) { $ok = 1; last; }
  }
  $ok or dief("Could not create switch '%s' (tried: %s)\n", $SWITCH, join(' | ', @candidates));
}

# apply opam env to this process
my $env_lines = capture($OPAM, 'env', '--switch', $SWITCH, '--set-switch', '--shell=sh');
$env_lines =~ s/\n/; /g;
for my $stmt (split /\s*;\s*/, $env_lines) {
  if ($stmt =~ /^\s*export\s+([A-Za-z_][A-Za-z0-9_]*)=(["']?)(.*?)\2\s*$/) {
    my ($k, $v) = ($1, $3);
    $ENV{$k} = $v;
  }
}

# Resolve tag/branch like PS script
my $cache_root = "$ENV{HOME}/.cache/omni-irc/src";
make_path($cache_root) if !-d $cache_root;
my $src_dir = "$cache_root/omni-irc-$REV";

my $ref = resolve_release_ref($REPO_URL, $REV);
my $pretty = $ref->{kind} eq 'tag' ? "tag $ref->{name}" : "branch $ref->{name}";
print "Cloning $REPO_URL @ $pretty -> $src_dir\n";
clone_or_update_shallow($REPO_URL, $ref, $src_dir);

# toolchain helpers
run($OPAM, 'install', '--switch', $SWITCH, 'dune', 'ocamlfind');

# pin all .opam packages (register only; no build yet), recursively
my @opam_files;
find(
  sub {
    return unless -f $_ && $_ =~ /\.opam$/;
    push @opam_files, $File::Find::name;
  },
  $src_dir
);

if (!@opam_files) {
  warn "No .opam files found under $src_dir. Ensure they are present (or generated).\n";
} else {
  print "Pinning packages (register only; no build yet) from: $src_dir\n";
  my %names = map {
    my ($n) = $_ =~ m{([^/\\]+)\.opam$};
    $n ? ($n => 1) : ()
  } @opam_files;
  for my $pkg (sort keys %names) {
    print "  - pinning $pkg\n";
    run($OPAM, 'pin', 'add', '--switch', $SWITCH, '-k', 'path', '--no-action', $pkg, $src_dir);
  }
  run($OPAM, 'pin', 'list', '--switch', $SWITCH);
}

# (opam ≥ 2.1) install system deps for the pinned client (best-effort)
eval { run($OPAM, 'install', '--switch', $SWITCH, '--depext-only', 'omni-irc-client'); 1 }
  or warn "depext-only step failed; you may need system libs (e.g., brew install gmp openssl\@3 pkg-config)\n";

# extra dep that may not be declared upstream
run($OPAM, 'install', '--switch', $SWITCH, 'yojson');

# install client
run($OPAM, 'install', '--switch', $SWITCH, 'omni-irc-client');

# report
my $bin = capture($OPAM, 'var', '--switch', $SWITCH, 'bin');
$bin =~ s/\s+$//;
print "omni-irc-client installed to: $bin\n";
my $exe = "$bin/omni-irc-client";
$exe .= '.exe' if $^O =~ /MSWin/;
if (-x $exe) { system($exe, '--help'); }

print "\nDone. This terminal now has:\n";
print "  OPAMROOT   = $ENV{OPAMROOT}\n";
print "  OPAMSWITCH = $SWITCH\n\n";
print "*******************************************************************\n";
print "*  Omni-IRC bootstrap is COMPLETE. You can now close this window. *\n";
print "*******************************************************************\n";
